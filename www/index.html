<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Buncombe Landslide Risk — Latest & History</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Near–real-time landslide risk map for Buncombe County, NC, with historical runs." />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100vw; }
    .topbar {
      position: absolute; z-index: 900; top: 10px; left: 50%;
      transform: translateX(-50%); background: rgba(255,255,255,0.92);
      padding: 8px 12px; border-radius: 8px; font: 14px/1.25 system-ui, sans-serif;
      box-shadow: 0 1px 4px rgba(0,0,0,.15); white-space: nowrap;
    }
    .subtitle { color:#444; margin-left:8px; font-weight:500; }
    .panel {
      position: absolute; z-index: 900; bottom: 16px; left: 12px;
      background: rgba(255,255,255,0.92); padding: 8px 10px; border-radius: 8px;
      font: 12px/1.25 system-ui, sans-serif; box-shadow: 0 1px 4px rgba(0,0,0,.15);
    }
    .legend { margin-top: 8px; }
    .swatch { width: 18px; height: 10px; display: inline-block; margin-right: 6px; vertical-align: -1px; }
    .slider { width: 220px; }
    .row { margin: 6px 0; }
    .about-btn, .runs-btn, .summary-btn {
      position: absolute; z-index: 910; top: 10px;
      background:#fff; border:1px solid #ccc; border-radius:8px; padding:6px 10px;
      font: 13px/1 system-ui, sans-serif; cursor:pointer; box-shadow:0 1px 4px rgba(0,0,0,.12);
    }
    .about-btn { right: 12px; }
    .runs-btn { right: 92px; }
    .summary-btn { right: 182px; }

    .overlay {
      position: absolute; z-index: 905; top: 56px; right: 12px; max-width: 380px;
      background: rgba(255,255,255,0.98); border:1px solid #ddd; border-radius:12px;
      padding: 12px 14px; box-shadow: 0 6px 24px rgba(0,0,0,.18); display: none;
      font: 13px/1.35 system-ui, sans-serif;
    }
    .overlay h3 { margin:0 0 6px 0; font-size:14px; }
    .overlay p { margin:6px 0; }
    .muted { color:#666; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .close-x { float:right; cursor:pointer; font-weight:700; padding:2px 6px; border-radius:6px; }
    .close-x:hover { background:#eee; }
    .row-inline { display:flex; gap:8px; align-items:center; }
    .select { font: 13px/1.2 system-ui, sans-serif; padding:4px 8px; }

    /* Welcome */
    #welcomeOverlay {
      position: fixed; inset: 0; z-index: 1200; display: flex; align-items: center; justify-content: center;
      transition: opacity .8s ease, visibility .8s ease; background: rgba(0,0,0,0.25);
    }
    #welcomeOverlay::before {
      content: ""; position: absolute; inset: 0;
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.35)), url('assets/welcome-bg.jpg') center/cover no-repeat;
      filter: saturate(1.05) contrast(1.05);
    }
    #welcomeOverlay.hidden { opacity: 0; visibility: hidden; }
    .welcome-box {
      position: relative; text-align: center; background: rgba(255,255,255,0.96);
      border-radius: 16px; padding: 28px 38px; box-shadow: 0 8px 24px rgba(0,0,0,0.25);
      color: #0b2239; max-width: 560px; backdrop-filter: blur(2px);
    }
    .welcome-box .logo { width: 84px; height: 84px; object-fit: contain; display:block; margin: 0 auto 12px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,.15); }
    .welcome-box h1 { margin: 0 0 10px; font-size: 1.9rem; color: #0b6; }
    .welcome-box p { margin: 6px 0; }
    .welcome-box .desc { color: #233; font-size: .98rem; margin: 12px 0 20px; line-height: 1.5; }
    #welcomeOverlay button { font-size: 1rem; padding: 10px 20px; border: none; border-radius: 8px; background: #0b6; color: #fff; cursor: pointer; transition: background .2s ease; }
    #welcomeOverlay button:hover { background: #099d60; }

    /* Scrollable About */
    #aboutBox { max-height: 70vh; overflow-y: auto; overscroll-behavior: contain; padding-right: 16px; }
  </style>
</head>
<body>
<div id="map"></div>

<!-- Welcome Screen -->
<div id="welcomeOverlay">
  <div class="welcome-box">
    <img class="logo" src="assets/logo.png" alt="Asheville Landslide Project logo" />
    <h1>Asheville Landslide Project</h1>
    <p><b>Real-Time Prediction of Rainfall-Triggered Landslides</b><br><span class="muted">Buncombe County, North Carolina</span></p>
    <p class="desc">This platform combines rainfall, terrain, and soil data to predict slope failure probability using machine learning. Explore live and historical predictions through interactive tools.</p>
    <p style="margin-top:16px; font-size:0.9rem; color:#333;"><b>Developed by Wonjun Choi</b><br>Grade 12, Asheville School</p>
    <button id="continueBtn">Continue</button>
  </div>
</div>

<button id="runsBtn" class="runs-btn" aria-haspopup="dialog" aria-controls="runsBox">Runs</button>
<button id="aboutBtn" class="about-btn" aria-haspopup="dialog" aria-controls="aboutBox">About</button>
<button id="summaryBtn" class="summary-btn" title="View project summary">Summary</button>

<div id="runsBox" class="overlay" role="dialog" aria-modal="false" aria-labelledby="runsTitle">
  <div><span id="runsClose" class="close-x" aria-label="Close">×</span></div>
  <h3 id="runsTitle">Choose a run</h3>
  <div class="row-inline">
    <label for="runSelect"><b>Date</b></label>
    <select id="runSelect" class="select" aria-label="Select date"></select>
    <span class="muted" id="runCount"></span>
  </div>
  <p class="muted" id="runPaths"></p>
</div>

<div id="aboutBox" class="overlay" role="dialog" aria-modal="false" aria-labelledby="aboutTitle">
  <div><span id="aboutClose" class="close-x" aria-label="Close">×</span></div>
  <h3 id="aboutTitle">About this map</h3>
  <p>
    This project was developed by <b>Wonjun Choi</b>, Grade 12 student at <b>Asheville School</b>,
    as part of a research initiative to apply data science and geospatial modeling for hazard prediction in Western North Carolina.
  </p>
  <p>
    This map is part of the <b>Asheville Landslide Project</b> — a real-time prediction system designed to
    assess <b>rainfall-triggered landslide risk</b> across <b>Buncombe County, North Carolina</b>.
    It translates a machine-learning model into a live map that updates automatically
    using recent rainfall data from <b>PRISM</b> and static geospatial layers.
  </p>
  <p>
    Each grid cell represents a 40-meter pixel derived from <b>USGS elevation</b> data, combined with
    <b>slope</b> and <b>soil depth</b> from the <b>NRCS SSURGO</b> database.
    The model incorporates rainfall windows: <b>R1d, R3d, R7d, R30d</b> and rolling maxima <b>Max 3-day</b>, <b>Max 30-day</b>.
  </p>
  <p>
    We trained Logistic Regression, <b>Random Forest</b>, and XGBoost using 302 mapped landslides (1981–2024) and
    matched controls. Random Forest delivered strong performance (AUC ≈ 0.89), capturing nonlinear rainfall–terrain effects.
  </p>
  <p>
    Key findings: <b>slope</b> is the most predictive static driver; <b>short-term rainfall</b> bursts (1–7 days, 3-day maxima)
    elevate risk; longer 30-day accumulation often reflects background wetness rather than immediate triggering.
  </p>
  <ul>
    <li><b>Latest predictions</b> from the daily run.</li>
    <li><b>Threshold slider</b> to filter higher-risk cells.</li>
    <li><b>Historical runs</b> via the “Runs” picker, backed by <code>/predictions/index.json</code>.</li>
    <li>Per-run artifacts under <code>/predictions/historicData/YYYY/MM/</code> (GeoJSON, Parquet, meta).</li>
  </ul>
  <p class="muted" id="aboutMeta">Latest run: — · model: Random Forest · prob: p_rf · rows: —</p>
  <p class="muted">Data endpoints: <code>/predictions/latest.json</code>, <code>/predictions/latest.geojson</code>, <code>/predictions/index.json</code></p>
</div>

<div class="topbar" id="topbar">
  Loading… <span class="subtitle" id="subtitle"></span>
</div>

<div class="panel" id="panel">
  <div class="row"><b>Threshold</b> p ≥ <span id="thv">0.00</span></div>
  <input id="th" class="slider" type="range" min="0" max="1" step="0.01" value="0" />
  <div class="legend" id="legend"></div>
</div>

<script>
(async function () {
  const top = document.getElementById('topbar');
  const subtitle = document.getElementById('subtitle');
  const th = document.getElementById('th');
  const thv = document.getElementById('thv');
  const legendDiv = document.getElementById('legend');
  const summaryBtn = document.getElementById('summaryBtn');
  const aboutBtn = document.getElementById('aboutBtn');
  const aboutBox = document.getElementById('aboutBox');
  const aboutClose = document.getElementById('aboutClose');
  const runsBtn = document.getElementById('runsBtn');
  const runsBox = document.getElementById('runsBox');
  const runsClose = document.getElementById('runsClose');
  const runSelect = document.getElementById('runSelect');
  const runCount = document.getElementById('runCount');
  const runPaths = document.getElementById('runPaths');
  const welcome = document.getElementById('welcomeOverlay');
  const continueBtn = document.getElementById('continueBtn');

  // Fixed probability domain
  const USE_FIXED_DOMAIN = true;
  const DOMAIN_MIN = 0.40;
  const DOMAIN_MAX = 1.00;

  let map, layer, features = [], probCol = 'p_rf';
  let manifest = { runs: [], latest: null };

  function setTop(msg){ top.firstChild.nodeValue = msg + ' '; }
  function show(el, show){ el.style.display = show ? 'block' : 'none'; }
  function toggle(el){ show(el, el.style.display !== 'block'); }

  continueBtn.addEventListener('click', () => { welcome.classList.add('hidden'); });

  summaryBtn.addEventListener('click', () => { window.open('project-summary.html', '_blank'); });
  aboutBtn.addEventListener('click', () => toggle(aboutBox));
  aboutClose.addEventListener('click', () => show(aboutBox, false));
  runsBtn.addEventListener('click', () => toggle(runsBox));
  runsClose.addEventListener('click', () => show(runsBox, false));
  document.addEventListener('keydown', e => { if (e.key === 'Escape') { show(aboutBox, false); show(runsBox, false); }});

  try {
    map = L.map('map', { preferCanvas: true }).setView([35.6, -82.5], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(map);
  } catch (e) { console.error('Leaflet init error:', e); setTop('Error: could not initialize map.'); return; }

  // Keep UI interactive over the map
  const panelEl = document.getElementById('panel');
  L.DomEvent.disableClickPropagation(panelEl);
  L.DomEvent.disableScrollPropagation(panelEl);
  ['aboutBox','runsBox','topbar'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      L.DomEvent.disableClickPropagation(el);
      L.DomEvent.disableScrollPropagation(el);
    }
  });
  ['mousedown','touchstart','pointerdown'].forEach(ev => {
    th.addEventListener(ev, e => e.stopPropagation(), { passive: true });
  });

  async function getJSON(url) {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) throw new Error(`${url} → HTTP ${r.status}`);
    return await r.json();
  }

  function setSubtitle(meta, modelKey) {
    const date = meta?.date || meta?.target_date || 'n/a';
    const rows = meta?.rows ?? 'n/a';
    const model = modelKey || 'Random Forest';
    setTop(`Run: ${date}`);
    subtitle.textContent = `model=${model} · prob_col=${probCol} · rows=${rows}`;
    document.getElementById('aboutMeta').textContent = `Latest run: ${date} · model: ${model} · prob: ${probCol} · rows: ${rows}`;
  }

  const stops = [[0.2,0.4,0.8],[0.1,0.7,0.7],[0.3,0.8,0.4],[0.9,0.9,0.2],[0.98,0.6,0.2],[0.8,0.1,0.1]];
  function lerp(a,b,t){ return a + (b-a)*t; }
  function colorScale(vMin, vMax){return p=>{
    if(!Number.isFinite(p))return'#999';
    const t=(p-vMin)/Math.max(1e-9,(vMax-vMin));
    const x=Math.max(0,Math.min(1,t))*(stops.length-1);
    const i=Math.floor(x),f=x-i;
    const c0=stops[i|0],c1=stops[Math.min(i+1,stops.length-1)];
    const r=Math.round(lerp(c0[0],c1[0],f)*255);
    const g=Math.round(lerp(c0[1],c1[1],f)*255);
    const b=Math.round(lerp(c0[2],c1[2],f)*255);
    return`rgb(${r},${g},${b})`;
  }}
  function renderLegend(vMin,vMax){
    const n=6,bins=[];for(let i=0;i<n;i++)bins.push(vMin+(i/(n-1))*(vMax-vMin));
    const getColor=colorScale(vMin,vMax);
    let html=`<b>${probCol}</b> (${vMin.toFixed(2)}–${vMax.toFixed(2)})<br>`;
    for(let i=0;i<bins.length-1;i++){
      const mid=(bins[i]+bins[i+1])/2;
      html+=`<span class="swatch" style="background:${getColor(mid)}"></span>${bins[i].toFixed(2)}–${bins[i+1].toFixed(2)}<br>`;
    }
    legendDiv.innerHTML=html;
  }
  const rainKeys=['R1d','R3d','R7d','R30d','Max_Rainfall_3day','Max_Rainfall_30day'];
  function propsPopup(p,probKey){
    const pv=Number(p[probKey]);
    let s=`${probKey}: ${Number.isFinite(pv)?pv.toFixed(3):'n/a'}`;
    for(const k of rainKeys)if(k in p)s+=`<br>${k}: ${Number(p[k]??0).toFixed(1)}`;
    if('row'in p&&'col'in p)s+=`<br>row: ${p.row} · col: ${p.col}`;
    return s;
  }
  function drawLayer(threshold,vMin,vMax){
    if(layer)map.removeLayer(layer);
    const getColor=colorScale(vMin,vMax);
    layer=L.geoJSON(
      {type:'FeatureCollection',features:features.filter(f=>Number(f.properties[probCol])>=threshold)},
      {
        pointToLayer:(f,latlng)=>{
          const p=Number(f.properties[probCol]);
          return L.circleMarker(latlng,{
            renderer:map.getRenderer(map),radius:3.2,fillColor:getColor(p),
            color:'#000',weight:0.2,opacity:0.9,fillOpacity:0.85
          }).bindPopup(propsPopup(f.properties,probCol));
        }
      }
    ).addTo(map);
    try{
      const b=layer.getBounds();
      if(b.isValid())map.fitBounds(b.pad(0.05),{animate:false});
    }catch(_){}
  }

  function recomputeAndRedraw(){
    // Data-driven min/max kept for fallback; fixed domain used by default
    const vals=features.map(f=>Number(f.properties[probCol])).filter(Number.isFinite);
    let dataMin=Math.min(...vals), dataMax=Math.max(...vals);
    if(!Number.isFinite(dataMin)||!Number.isFinite(dataMax)||dataMax<=dataMin){dataMin=0;dataMax=1;}

    const vMin = USE_FIXED_DOMAIN ? DOMAIN_MIN : dataMin;
    const vMax = USE_FIXED_DOMAIN ? DOMAIN_MAX : dataMax;

    th.min=vMin.toFixed(2);
    th.max=vMax.toFixed(2);
    th.step='0.01';

    const cur=Number(th.value);
    if(!Number.isFinite(cur)||cur<vMin||cur>vMax){
      th.value=(USE_FIXED_DOMAIN ? 0.50 : (vMin+0.1*(vMax-vMin))).toFixed(2);
    }

    thv.textContent=Number(th.value).toFixed(2);
    renderLegend(vMin,vMax);
    drawLayer(Number(th.value),vMin,vMax);
  }

  let debounce=null;
  th.addEventListener('input',()=>{
    thv.textContent=Number(th.value).toFixed(2);
    clearTimeout(debounce);
    debounce=setTimeout(()=>recomputeAndRedraw(),80);
  });

  async function loadLatest(){
    try{
      const meta=await getJSON('/predictions/latest.json');
      probCol=meta.prob_col||'p_rf';
      setSubtitle(meta);
    }catch(e){ console.warn('latest.json missing'); }
    const geo=await getJSON('/predictions/latest.geojson');
    features=(geo.features||[]).filter(f=>f&&f.properties);
    recomputeAndRedraw();
    runPaths.innerHTML=`<span class="muted">GeoJSON:</span> <code class="mono">/predictions/latest.geojson</code>`;
  }

  async function loadByDate(dateStr){
    const rec=(manifest.runs||[]).find(r=>r.date===dateStr);
    if(!rec)throw new Error(`Run not found: ${dateStr}`);
    const meta=await getJSON('/'+rec.meta);
    probCol=(meta.prob_col||'p_rf');
    setSubtitle(meta);
    const geo=await getJSON('/'+rec.geojson);
    features=(geo.features||[]).filter(f=>f&&f.properties);
    recomputeAndRedraw();
    runPaths.innerHTML=`<span class="muted">GeoJSON:</span> <code class="mono">/${rec.geojson}</code><br><span class="muted">Parquet:</span> <code class="mono">/${rec.parquet}</code>`;
  }

  function populateRuns(){
    runSelect.innerHTML='';
    const optL=document.createElement('option');
    optL.value='__latest__'; optL.textContent='Latest';
    runSelect.appendChild(optL);
    for(const r of (manifest.runs||[])){
      const o=document.createElement('option'); o.value=r.date; o.textContent=r.date;
      runSelect.appendChild(o);
    }
    runCount.textContent=`${(manifest.runs||[]).length} archived`;
    runSelect.value='__latest__';
  }

  runSelect.addEventListener('change',async e=>{
    const v=e.target.value;
    try{
      setTop('Loading…');
      if(v==='__latest__') await loadLatest();
      else await loadByDate(v);
    }catch(err){
      console.error(err);
      setTop('Load error');
    }
  });

  try{ manifest=await getJSON('/predictions/index.json'); }
  catch(e){ console.warn('index.json missing'); manifest={runs:[],latest:null}; }

  populateRuns();
  await loadLatest();
})();
</script>
</body>
</html>
