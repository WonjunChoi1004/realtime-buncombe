<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Buncombe Landslide Risk — Latest & History</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Near–real-time landslide risk map for Buncombe County, NC, with historical runs." />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100vw; }
    .topbar {
      position: absolute; z-index: 900; top: 10px; left: 50%;
      transform: translateX(-50%); background: rgba(255,255,255,0.92);
      padding: 8px 12px; border-radius: 8px; font: 14px/1.25 system-ui, sans-serif;
      box-shadow: 0 1px 4px rgba(0,0,0,.15); white-space: nowrap;
    }
    .subtitle { color:#444; margin-left:8px; font-weight:500; }
    .panel {
      position: absolute; z-index: 900; bottom: 16px; left: 12px;
      background: rgba(255,255,255,0.92); padding: 10px 12px; border-radius: 10px;
      font: 12px/1.25 system-ui, sans-serif; box-shadow: 0 1px 4px rgba(0,0,0,.15); min-width: 280px;
    }
    .legend { margin-top: 8px; }
    .swatch { width: 18px; height: 10px; display: inline-block; margin-right: 6px; vertical-align: -1px; }
    .slider { width: 100%; }
    .row { margin: 8px 0; display:flex; align-items:center; gap:8px; }
    .row label { white-space:nowrap; }
    .btn { background:#fff; border:1px solid #ccc; border-radius:8px; padding:6px 10px; cursor:pointer; box-shadow:0 1px 4px rgba(0,0,0,.12); }
    .about-btn, .runs-btn, .summary-btn {
      position: absolute; z-index: 910; top: 10px;
      background:#fff; border:1px solid #ccc; border-radius:8px; padding:6px 10px;
      font: 13px/1 system-ui, sans-serif; cursor:pointer; box-shadow: 0 1px 4px rgba(0,0,0,.12);
    }
    .about-btn { right: 12px; }
    .runs-btn { right: 92px; }
    .summary-btn { right: 182px; }

    .overlay {
      position: absolute; z-index: 905; top: 56px; right: 12px; max-width: 380px;
      background: rgba(255,255,255,0.98); border:1px solid #ddd; border-radius:12px;
      padding: 12px 14px; box-shadow: 0 6px 24px rgba(0,0,0,.18); display: none;
      font: 13px/1.35 system-ui, sans-serif;
    }
    .overlay h3 { margin:0 0 6px 0; font-size:14px; }
    .overlay p { margin:6px 0; }
    .muted { color:#666; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .close-x { float:right; cursor:pointer; font-weight:700; padding:2px 6px; border-radius:6px; }
    .close-x:hover { background:#eee; }
    .row-inline { display:flex; gap:8px; align-items:center; }
    .select { font: 13px/1.2 system-ui, sans-serif; padding:4px 8px; }

    /* Welcome */
    #welcomeOverlay { position: fixed; inset: 0; z-index: 1200; display: flex; align-items: center; justify-content: center;
      transition: opacity .8s ease, visibility .8s ease; background: rgba(0,0,0,0.25); }
    #welcomeOverlay::before { content: ""; position: absolute; inset: 0;
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.35)), url('assets/welcome-bg.jpg') center/cover no-repeat; }
    #welcomeOverlay.hidden { opacity: 0; visibility: hidden; }
    .welcome-box { position: relative; text-align: center; background: rgba(255,255,255,0.96);
      border-radius: 16px; padding: 28px 38px; box-shadow: 0 8px 24px rgba(0,0,0,0.25);
      color: #0b2239; max-width: 560px; backdrop-filter: blur(2px); }
    .welcome-box .logo { width: 84px; height: 84px; object-fit: contain; display:block; margin: 0 auto 12px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,.15); }
    .welcome-box h1 { margin: 0 0 10px; font-size: 1.9rem; color: #0b6; }
    .welcome-box p { margin: 6px 0; }
    .welcome-box .desc { color: #233; font-size: .98rem; margin: 12px 0 20px; line-height: 1.5; }
    #welcomeOverlay button { font-size: 1rem; padding: 10px 20px; border: none; border-radius: 8px; background: #0b6; color: #fff; cursor: pointer; }
    #welcomeOverlay button:hover { background: #099d60; }

    /* Scrollable About */
    #aboutBox { max-height: 70vh; overflow-y: auto; overscroll-behavior: contain; padding-right: 16px; }
    .toggle { display:inline-flex; align-items:center; gap:6px; cursor:pointer; }
  </style>
</head>
<body>
<div id="map"></div>

<!-- Welcome Screen -->
<div id="welcomeOverlay">
  <div class="welcome-box">
    <img class="logo" src="assets/logo.png" alt="Asheville Landslide Project logo" />
    <h1>Asheville Landslide Project</h1>
    <p><b>Real-Time Prediction of Rainfall-Triggered Landslides</b><br><span class="muted">Buncombe County, North Carolina</span></p>
    <p class="desc">This platform combines rainfall, terrain, and soil data to predict slope failure probability using machine learning. Explore live and historical predictions through interactive tools.</p>
    <p style="margin-top:16px; font-size:0.9rem; color:#333;"><b>Developed by Wonjun Choi</b><br>Grade 12, Asheville School</p>
    <button id="continueBtn">Continue</button>
  </div>
</div>

<button id="runsBtn" class="runs-btn" aria-haspopup="dialog" aria-controls="runsBox">Runs</button>
<button id="aboutBtn" class="about-btn" aria-haspopup="dialog" aria-controls="aboutBox">About</button>
<button id="summaryBtn" class="summary-btn" title="View project summary">Summary</button>

<div id="runsBox" class="overlay" role="dialog" aria-modal="false" aria-labelledby="runsTitle">
  <div><span id="runsClose" class="close-x" aria-label="Close">×</span></div>
  <h3 id="runsTitle">Choose a run</h3>
  <div class="row-inline">
    <label for="runSelect"><b>Date</b></label>
    <select id="runSelect" class="select" aria-label="Select date"></select>
    <span class="muted" id="runCount"></span>
  </div>
  <p class="muted" id="runPaths"></p>
</div>

<div id="aboutBox" class="overlay" role="dialog" aria-modal="false" aria-labelledby="aboutTitle">
  <div><span id="aboutClose" class="close-x" aria-label="Close">×</span></div>
  <h3 id="aboutTitle">About this map</h3>
  <p>
    This project was developed by <b>Wonjun Choi</b>, Grade 12 student at <b>Asheville School</b>,
    as part of a research initiative to apply data science and geospatial modeling for hazard prediction in Western North Carolina.
  </p>
  <p>
    This map is part of the <b>Asheville Landslide Project</b> — a real-time prediction system designed to
    assess <b>rainfall-triggered landslide risk</b> across <b>Buncombe County, North Carolina</b>.
    It translates a machine-learning model into a live map that updates automatically
    using recent rainfall data from <b>PRISM</b> and static geospatial layers.
  </p>
  <p>
    Each grid cell represents a 40-meter pixel derived from <b>USGS elevation</b> data, combined with
    <b>slope</b> and <b>soil depth</b> from the <b>NRCS SSURGO</b> database.
    The model incorporates rainfall windows: <b>R1d, R3d, R7d, R30d</b> and rolling maxima <b>Max 3-day</b>, <b>Max 30-day</b>.
  </p>
  <p>
    We trained Logistic Regression, <b>Random Forest</b>, and XGBoost using 302 mapped landslides (1981–2024) and
    matched controls. Random Forest delivered strong performance (AUC ≈ 0.89), capturing nonlinear rainfall–terrain effects.
  </p>
  <p>
    Key findings: <b>slope</b> is the most predictive static driver; <b>short-term rainfall</b> bursts (1–7 days, 3-day maxima)
    elevate risk; longer 30-day accumulation often reflects background wetness rather than immediate triggering.
  </p>
  <ul>
    <li><b>Latest predictions</b> from the daily run.</li>
    <li><b>Threshold slider</b> to filter higher-risk cells.</li>
    <li><b>Historical runs</b> via the “Runs” picker, backed by <code>/predictions/index.json</code>.</li>
    <li>Per-run artifacts under <code>/predictions/historicData/YYYY/MM/</code> (GeoJSON, Parquet, meta).</li>
  </ul>
  <p class="muted" id="aboutMeta">Latest run: — · model: Random Forest · prob: p_rf · rows: —</p>
  <p class="muted">Data endpoints: <code>/predictions/latest.json</code>, <code>/predictions/latest.geojson</code>, <code>/predictions/index.json</code></p>
</div>

<div class="topbar" id="topbar">
  Loading… <span class="subtitle" id="subtitle"></span>
</div>

<div class="panel" id="panel">
  <div class="row"><label><b>Threshold</b></label> p ≥ <span id="thv">0.00</span></div>
  <input id="th" class="slider" type="range" min="0" max="1" step="0.01" value="0" />
  <div class="legend" id="legend"></div>

  <hr style="border:none;border-top:1px solid #ddd;margin:10px 0">

  <div class="row" style="justify-content:space-between;">
    <label><b>Date</b> <span id="dateLabel" class="mono muted">—</span></label>
    <label class="toggle" title="Loop autoplay"><input id="loopToggle" type="checkbox" checked>Loop</label>
  </div>
  <div class="row" style="gap:6px;">
    <button id="prevDate" class="btn" title="Previous day">◀</button>
    <input id="dateSlider" class="slider" type="range" min="0" max="0" step="1" value="0" />
    <button id="nextDate" class="btn" title="Next day">▶</button>
    <button id="playBtn" class="btn" title="Play/Pause">▶</button>
    <button id="fitBtn" class="btn" title="Fit to current points">Fit</button>
  </div>
</div>

<script>
(async function () {
  const top = document.getElementById('topbar');
  const subtitle = document.getElementById('subtitle');
  const th = document.getElementById('th');
  const thv = document.getElementById('thv');
  const legendDiv = document.getElementById('legend');
  const summaryBtn = document.getElementById('summaryBtn');
  const aboutBtn = document.getElementById('aboutBtn');
  const aboutBox = document.getElementById('aboutBox');
  const aboutClose = document.getElementById('aboutClose');
  const runsBtn = document.getElementById('runsBtn');
  const runsBox = document.getElementById('runsBox');
  const runsClose = document.getElementById('runsClose');
  const runSelect = document.getElementById('runSelect');
  const runCount = document.getElementById('runCount');
  const runPaths = document.getElementById('runPaths');
  const welcome = document.getElementById('welcomeOverlay');
  const continueBtn = document.getElementById('continueBtn');

  const dateSlider = document.getElementById('dateSlider');
  const dateLabel = document.getElementById('dateLabel');
  const prevDateBtn = document.getElementById('prevDate');
  const nextDateBtn = document.getElementById('nextDate');
  const playBtn = document.getElementById('playBtn');
  const loopToggle = document.getElementById('loopToggle');
  const fitBtn = document.getElementById('fitBtn');

  const USE_FIXED_DOMAIN = true;
  const DOMAIN_MIN = 0.00;
  const DOMAIN_MAX = 1.00;
  const LEGEND_BREAKS = [0.00, 0.40, 0.60, 0.70, 0.80, 0.90, 1.00];

  // Autoplay config
  const AUTOPLAY_MS = 900; // step interval
  let playTimer = null;
  let isPlaying = false;

  let map, layer, features = [], probCol = 'p_rf';
  let manifest = { runs: [], latest: null };
  let dateList = []; // chronological: left = oldest, right = newest
  let currentDate = null;

  function setTop(msg){ top.firstChild.nodeValue = msg + ' '; }
  function show(el, show){ el.style.display = show ? 'block' : 'none'; }
  function toggle(el){ show(el, el.style.display !== 'block'); }

  continueBtn.addEventListener('click', () => { welcome.classList.add('hidden'); });

  summaryBtn.addEventListener('click', () => { window.open('project-summary.html', '_blank'); });
  aboutBtn.addEventListener('click', () => toggle(aboutBox));
  aboutClose.addEventListener('click', () => show(aboutBox, false));
  runsBtn.addEventListener('click', () => toggle(runsBox));
  runsClose.addEventListener('click', () => show(runsBox, false));
  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') { show(aboutBox, false); show(runsBox, false); }
    if (e.key === ' ') { e.preventDefault(); togglePlay(); }
    if (e.key === 'ArrowLeft') stepDate(-1);
    if (e.key === 'ArrowRight') stepDate(1);
  });

  try {
    map = L.map('map', { preferCanvas: true }).setView([35.6, -82.5], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(map);
  } catch (e) { console.error('Leaflet init error:', e); setTop('Error: could not initialize map.'); return; }

  const panelEl = document.getElementById('panel');
  L.DomEvent.disableClickPropagation(panelEl);
  L.DomEvent.disableScrollPropagation(panelEl);
  ['aboutBox','runsBox','topbar'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      L.DomEvent.disableClickPropagation(el);
      L.DomEvent.disableScrollPropagation(el);
    }
  });
  ['mousedown','touchstart','pointerdown'].forEach(ev => {
    th.addEventListener(ev, e => e.stopPropagation(), { passive: true });
    dateSlider.addEventListener(ev, e => e.stopPropagation(), { passive: true });
  });

  async function getJSON(url) {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) throw new Error(`${url} → HTTP ${r.status}`);
    return await r.json();
  }

  function setSubtitle(meta, modelKey) {
    const date = meta?.date || meta?.target_date || 'n/a';
    const rows = meta?.rows ?? 'n/a';
    const model = modelKey || 'Random Forest';
    setTop(`Run: ${date}`);
    subtitle.textContent = `model=${model} · prob_col=${probCol} · rows=${rows}`;
    document.getElementById('aboutMeta').textContent = `Latest run: ${date} · model: ${model} · prob: ${probCol} · rows: ${rows}`;
  }

  // Colors across custom bins
  const stops = [[0.2,0.4,0.8],[0.1,0.7,0.7],[0.3,0.8,0.4],[0.9,0.9,0.2],[0.98,0.6,0.2],[0.8,0.1,0.1]];
  function lerp(a,b,t){ return a + (b-a)*t; }
  function piecewiseT(p, breaks){
    const n = breaks.length - 1;
    if (p <= breaks[0]) return 0;
    if (p >= breaks[breaks.length-1]) return 1;
    for (let i=0;i<n;i++){
      const a = breaks[i], b = breaks[i+1];
      if (p <= b) {
        const local = (p - a) / Math.max(1e-9, (b - a));
        return (i + local) / n;
      }
    }
    return 1;
  }
  function colorScalePiecewise(breaks){
    return p=>{
      if(!Number.isFinite(p))return'#999';
      const t = piecewiseT(p, breaks) * (stops.length - 1);
      const i = Math.floor(t), f = t - i;
      const c0 = stops[i|0], c1 = stops[Math.min(i+1, stops.length-1)];
      const r = Math.round(lerp(c0[0], c1[0], f)*255);
      const g = Math.round(lerp(c0[1], c1[1], f)*255);
      const b = Math.round(lerp(c0[2], c1[2], f)*255);
      return `rgb(${r},${g},${b})`;
    }
  }
  function renderLegendWithBreaks(breaks){
    const getColor = colorScalePiecewise(breaks);
    let html = `<b>${probCol}</b> (custom bins)<br>`;
    for(let i=0;i<breaks.length-1;i++){
      const a = breaks[i], b = breaks[i+1];
      const mid = (a+b)/2;
      html += `<span class="swatch" style="background:${getColor(mid)}"></span>${a.toFixed(2)}–${b.toFixed(2)}<br>`;
    }
    legendDiv.innerHTML = html;
  }

  const rainKeys=['R1d','R3d','R7d','R30d','Max_Rainfall_3day','Max_Rainfall_30day'];
  function propsPopup(p,probKey){
    const pv=Number(p[probKey]);
    let s=`${probKey}: ${Number.isFinite(pv)?pv.toFixed(3):'n/a'}`;
    for(const k of rainKeys)if(k in p)s+=`<br>${k}: ${Number(p[k]??0).toFixed(1)}`;
    if('row'in p&&'col'in p)s+=`<br>row: ${p.row} · col: ${p.col}`;
    return s;
  }

  // No auto-zoom on threshold/date change. Use "Fit" to frame.
  function drawLayer(threshold, breaks){
    if(layer)map.removeLayer(layer);
    const getColor=colorScalePiecewise(breaks);
    layer=L.geoJSON(
      {type:'FeatureCollection',features:features.filter(f=>Number(f.properties[probCol])>=threshold)},
      {
        pointToLayer:(f,latlng)=>{
          const p=Number(f.properties[probCol]);
          return L.circleMarker(latlng,{
            renderer:map.getRenderer(map),radius:3.2,fillColor:getColor(p),
            color:'#000',weight:0.2,opacity:0.9,fillOpacity:0.85
          }).bindPopup(propsPopup(f.properties,probCol));
        }
      }
    ).addTo(map);
  }

  function fitToLayer(){
    try{
      if(!layer) return;
      const b=layer.getBounds();
      if(b && b.isValid()) map.fitBounds(b.pad(0.05),{animate:false});
    }catch(_){}
  }

  function recomputeAndRedraw(){
    const vMin = USE_FIXED_DOMAIN ? DOMAIN_MIN : 0;
    const vMax = USE_FIXED_DOMAIN ? DOMAIN_MAX : 1;
    th.min=vMin.toFixed(2); th.max=vMax.toFixed(2); th.step='0.01';
    const cur=Number(th.value);
    if(!Number.isFinite(cur)||cur<vMin||cur>vMax){ th.value='0.50'; }
    thv.textContent=Number(th.value).toFixed(2);
    renderLegendWithBreaks(LEGEND_BREAKS);
    drawLayer(Number(th.value), LEGEND_BREAKS);
  }

  let debounce=null;
  th.addEventListener('input',()=>{
    thv.textContent=Number(th.value).toFixed(2);
    clearTimeout(debounce);
    debounce=setTimeout(()=>recomputeAndRedraw(),80);
  });

  function buildRecentDateList() {
    const runs = (manifest.runs||[]); // expected sorted desc by date
    if (!runs.length) return [];
    // take up to last 30 by date (newest first), then reverse to chronological
    const newestFirst = runs.map(r=>r.date).filter(Boolean);
    const unique = Array.from(new Set(newestFirst));
    const slice = unique.slice(0, 30);
    return slice.reverse(); // chronological: left=oldest, right=newest
  }

  function syncDateSlider() {
    dateList = buildRecentDateList();
    if (!dateList.length) {
      dateSlider.style.display = 'none';
      prevDateBtn.style.display = 'none';
      nextDateBtn.style.display = 'none';
      playBtn.style.display = 'none';
      dateLabel.textContent = '—';
      return;
    }
    dateSlider.style.display = 'block';
    prevDateBtn.style.display = 'inline-block';
    nextDateBtn.style.display = 'inline-block';
    playBtn.style.display = 'inline-block';
    dateSlider.min = 0;
    dateSlider.max = Math.max(0, dateList.length - 1);

    // Default knob at rightmost (most recent)
    const idx = (currentDate ? Math.max(0, dateList.indexOf(currentDate)) : dateList.length - 1);
    dateSlider.value = idx;
    dateLabel.textContent = dateList[idx];
  }

  async function setDateByIndex(idx) {
    idx = Math.max(Number(dateSlider.min), Math.min(Number(dateSlider.max), idx));
    const target = dateList[idx];
    if (!target) return;
    try {
      setTop('Loading…');
      await loadByDate(target);
      currentDate = target;
      dateSlider.value = idx;
      dateLabel.textContent = target;
    } catch (err) {
      console.error(err);
      setTop('Load error');
    }
  }

  async function stepDate(delta) {
    const idx = Number(dateSlider.value) + delta;
    await setDateByIndex(idx);
  }

  // Chronological autoplay: move right until end; loop if toggled
  function startPlay(){
    if (isPlaying || !dateList.length) return;
    isPlaying = true;
    playBtn.textContent = '⏸';
    playTimer = setInterval(async () => {
      let idx = Number(dateSlider.value);
      if (idx < Number(dateSlider.max)) {
        await setDateByIndex(idx + 1);
      } else {
        if (loopToggle.checked) {
          await setDateByIndex(Number(dateSlider.min));
        } else {
          stopPlay();
        }
      }
    }, AUTOPLAY_MS);
  }
  function stopPlay(){
    isPlaying = false;
    playBtn.textContent = '▶';
    if (playTimer) { clearInterval(playTimer); playTimer = null; }
  }
  function togglePlay(){ isPlaying ? stopPlay() : startPlay(); }

  dateSlider.addEventListener('input', async ()=>{ await setDateByIndex(Number(dateSlider.value)); });
  prevDateBtn.addEventListener('click', ()=> stepDate(-1));
  nextDateBtn.addEventListener('click', ()=> stepDate(1));
  playBtn.addEventListener('click', togglePlay);
  fitBtn.addEventListener('click', fitToLayer);

  async function loadLatest(){
    try{
      const meta=await getJSON('/predictions/latest.json');
      probCol=meta.prob_col||'p_rf';
      setSubtitle(meta);
      currentDate = meta.date || currentDate;
    }catch(e){ console.warn('latest.json missing'); }
    const geo=await getJSON('/predictions/latest.geojson');
    features=(geo.features||[]).filter(f=>f&&f.properties);
    recomputeAndRedraw();
    runPaths.innerHTML=`<span class="muted">GeoJSON:</span> <code class="mono">/predictions/latest.geojson</code>`;
  }

  async function loadByDate(dateStr){
    const rec=(manifest.runs||[]).find(r=>r.date===dateStr);
    if(!rec)throw new Error(`Run not found: ${dateStr}`);
    const meta=await getJSON('/'+rec.meta);
    probCol=(meta.prob_col||'p_rf');
    setSubtitle(meta);
    const geo=await getJSON('/'+rec.geojson);
    features=(geo.features||[]).filter(f=>f&&f.properties);
    recomputeAndRedraw();
    runPaths.innerHTML=`<span class="muted">GeoJSON:</span> <code class="mono">/${rec.geojson}</code><br><span class="muted">Parquet:</span> <code class="mono">/${rec.parquet}</code>`;
  }

  function populateRuns(){
    runSelect.innerHTML='';
    const optL=document.createElement('option');
    optL.value='__latest__'; optL.textContent='Latest';
    runSelect.appendChild(optL);
    for(const r of (manifest.runs||[])){
      const o=document.createElement('option'); o.value=r.date; o.textContent=r.date;
      runSelect.appendChild(o);
    }
    runCount.textContent=`${(manifest.runs||[]).length} archived`;
    runSelect.value='__latest__';
  }

  runSelect.addEventListener('change',async e=>{
    const v=e.target.value;
    try{
      setTop('Loading…');
      if(v==='__latest__') { await loadLatest(); }
      else { await loadByDate(v); currentDate = v; }
      syncDateSlider();
    }catch(err){
      console.error(err);
      setTop('Load error');
    }
  });

  try{ manifest=await getJSON('/predictions/index.json'); }
  catch(e){ console.warn('index.json missing'); manifest={runs:[],latest:null}; }

  populateRuns();
  await loadLatest();
  syncDateSlider();
  if (dateList.length) { dateLabel.textContent = dateList[dateList.length-1]; } // newest on right

})();
</script>
</body>
</html>
