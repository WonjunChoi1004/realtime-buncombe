<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Buncombe Landslide Risk — Latest</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Near–real-time landslide risk map for Buncombe County, NC. Fuses daily rainfall windows with terrain and soils to show grid cells exceeding a chosen probability threshold." />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100vw; }
    .topbar {
      position: absolute; z-index: 900; top: 10px; left: 50%;
      transform: translateX(-50%); background: rgba(255,255,255,0.92);
      padding: 8px 12px; border-radius: 8px; font: 14px/1.25 system-ui, sans-serif;
      box-shadow: 0 1px 4px rgba(0,0,0,.15); white-space: nowrap;
    }
    .subtitle { color:#444; margin-left:8px; font-weight:500; }
    .panel {
      position: absolute; z-index: 900; bottom: 16px; left: 12px;
      background: rgba(255,255,255,0.92); padding: 8px 10px; border-radius: 8px;
      font: 12px/1.25 system-ui, sans-serif; box-shadow: 0 1px 4px rgba(0,0,0,.15);
    }
    .legend { margin-top: 8px; }
    .swatch { width: 18px; height: 10px; display: inline-block; margin-right: 6px; vertical-align: -1px; }
    .slider { width: 220px; }
    .row { margin: 6px 0; }

    /* About button + overlay */
    .about-btn {
      position: absolute; z-index: 910; top: 10px; right: 12px;
      background:#fff; border:1px solid #ccc; border-radius:8px; padding:6px 10px;
      font: 13px/1 system-ui, sans-serif; cursor:pointer; box-shadow:0 1px 4px rgba(0,0,0,.12);
    }
    .about-overlay {
      position: absolute; z-index: 905; top: 56px; right: 12px; max-width: 360px;
      background: rgba(255,255,255,0.98); border:1px solid #ddd; border-radius:12px;
      padding: 12px 14px; box-shadow: 0 6px 24px rgba(0,0,0,.18); display: none;
      font: 13px/1.35 system-ui, sans-serif;
    }
    .about-overlay h3 { margin:0 0 6px 0; font-size:14px; }
    .about-overlay p { margin:6px 0; }
    .about-row { color:#333; }
    .muted { color:#666; }
    .linklike { color:#0b6; text-decoration:none; }
    .close-x { float:right; cursor:pointer; font-weight:700; padding:2px 6px; border-radius:6px; }
    .close-x:hover { background:#eee; }
  </style>
</head>
<body>
<div id="map"></div>

<button id="aboutBtn" class="about-btn" aria-haspopup="dialog" aria-controls="aboutBox">About</button>
<div id="aboutBox" class="about-overlay" role="dialog" aria-modal="false" aria-labelledby="aboutTitle">
  <div><span id="aboutClose" class="close-x" aria-label="Close">×</span></div>
  <h3 id="aboutTitle">About this map</h3>
  <p class="about-row">
    This site shows a <b>near–real-time landslide risk</b> layer for <b>Buncombe County, NC</b>.
    It combines <b>daily rainfall windows</b> (e.g., 1–30&nbsp;day sums and 3/30-day maxima)
    with <b>terrain</b> (elevation, slope) and <b>soil depth</b> to estimate the probability that a grid cell is susceptible to rainfall-triggered landslides today.
  </p>
  <p class="about-row">
    Use the <b>Threshold</b> slider to reveal only grid cells with predicted probability
    <em>p</em> above your chosen cutoff. The legend reflects the current probability scale (<span class="muted">darker = higher</span>).
  </p>
  <p class="about-row muted" id="aboutMeta">Latest run: — · model: — · prob: — · rows: —</p>
  <p class="about-row muted">
    Data endpoints: <code>/api/latest</code> (metadata) and <code>/predictions/latest.geojson</code> (tiles/grid).
  </p>
</div>

<div class="topbar" id="topbar">
  Loading… <span class="subtitle" id="subtitle"></span>
</div>

<div class="panel" id="panel">
  <div class="row"><b>Threshold</b> p ≥ <span id="thv">0.00</span></div>
  <input id="th" class="slider" type="range" min="0" max="1" step="0.01" value="0" />
  <div class="legend" id="legend"></div>
</div>

<script>
(async function () {
  const top = document.getElementById('topbar');
  const subtitle = document.getElementById('subtitle');
  const th = document.getElementById('th');
  const thv = document.getElementById('thv');
  const legendDiv = document.getElementById('legend');

  const aboutBtn = document.getElementById('aboutBtn');
  const aboutBox = document.getElementById('aboutBox');
  const aboutClose = document.getElementById('aboutClose');
  const aboutMeta = document.getElementById('aboutMeta');

  function setTop(msg){ top.firstChild.nodeValue = msg + ' '; }

  // About toggle
  function showAbout(show){
    aboutBox.style.display = show ? 'block' : 'none';
    aboutBtn.setAttribute('aria-expanded', show ? 'true' : 'false');
  }
  aboutBtn.addEventListener('click', () => showAbout(aboutBox.style.display !== 'block'));
  aboutClose.addEventListener('click', () => showAbout(false));
  document.addEventListener('keydown', e => { if (e.key === 'Escape') showAbout(false); });

  // Map
  let map;
  try {
    map = L.map('map', { preferCanvas: true }).setView([35.6, -82.5], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);
  } catch (e) {
    console.error('Leaflet init error:', e);
    setTop('Error: could not initialize map.');
    return;
  }

  async function getJSON(url) {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) throw new Error(`${url} → HTTP ${r.status}`);
    return await r.json();
  }

  // Load meta + data
  let meta, probCol = 'p_logistic';
  let features = [];
  try {
    meta = await getJSON('/api/latest');
    probCol = meta.prob_col || 'p_logistic';
    const date = meta.target_date || 'n/a';
    const model = meta.model || 'n/a';
    const rows = meta.rows ?? 'n/a';

    setTop(`Latest: ${date}`);
    subtitle.textContent = `model=${model} · prob_col=${probCol} · rows=${rows}`;
    aboutMeta.textContent = `Latest run: ${date} · model: ${model} · prob: ${probCol} · rows: ${rows}`;
  } catch (e) {
    console.error('Meta error:', e);
    setTop('Latest info unavailable');
    subtitle.textContent = '';
  }

  try {
    const geo = await getJSON('/predictions/latest.geojson');
    features = (geo.features || []).filter(f => f && f.properties);
  } catch (e) {
    console.error('GeoJSON load error:', e);
    setTop('Error loading latest.geojson');
    return;
  }

  // Domain
  const vals = features.map(f => Number(f.properties[probCol])).filter(Number.isFinite);
  const dataMin = Math.min(...vals);
  const dataMax = Math.max(...vals);
  const vMin = Number.isFinite(dataMin) ? dataMin : 0;
  const vMax = Number.isFinite(dataMax) ? dataMax : 1;
  th.min = vMin.toFixed(2);
  th.max = vMax.toFixed(2);
  if (vMax - vMin > 0.2) th.value = (vMin + 0.1*(vMax - vMin)).toFixed(2);
  thv.textContent = Number(th.value).toFixed(2);

  // Color scale
  const stops = [
    [0.2, 0.4, 0.8],
    [0.1, 0.7, 0.7],
    [0.3, 0.8, 0.4],
    [0.9, 0.9, 0.2],
    [0.98, 0.6, 0.2],
    [0.8, 0.1, 0.1],
  ];
  function lerp(a,b,t){ return a + (b-a)*t; }
  function getColor(p) {
    if (!Number.isFinite(p)) return '#999';
    const t = (p - vMin) / Math.max(1e-9, (vMax - vMin));
    const x = Math.max(0, Math.min(1, t)) * (stops.length - 1);
    const i = Math.floor(x), f = x - i;
    const c0 = stops[i|0], c1 = stops[Math.min(i+1, stops.length-1)];
    const r = Math.round(lerp(c0[0], c1[0], f)*255);
    const g = Math.round(lerp(c0[1], c1[1], f)*255);
    const b = Math.round(lerp(c0[2], c1[2], f)*255);
    return `rgb(${r},${g},${b})`;
  }

  // Legend
  function renderLegend() {
    const n = 6;
    let bins = [];
    for (let i=0;i<n;i++){
      const a = vMin + (i/(n-1))*(vMax - vMin);
      bins.push(a);
    }
    let html = `<b>${probCol}</b> (${vMin.toFixed(2)}–${vMax.toFixed(2)})<br>`;
    for (let i=0;i<bins.length-1;i++){
      const mid = (bins[i] + bins[i+1]) / 2;
      html += `<span class="swatch" style="background:${getColor(mid)}"></span>${bins[i].toFixed(2)}–${bins[i+1].toFixed(2)}<br>`;
    }
    legendDiv.innerHTML = html;
  }
  renderLegend();

  // Popup
  const rainKeys = ['R1d','R3d','R7d','R30d','Max_Rainfall_3day','Max_Rainfall_30day'];
  function propsPopup(p, probKey) {
    const pv = Number(p[probKey]);
    let s = `${probKey}: ${Number.isFinite(pv) ? pv.toFixed(3) : 'n/a'}`;
    for (const k of rainKeys) if (k in p) s += `<br>${k}: ${Number(p[k] ?? 0).toFixed(1)}`;
    if ('row' in p && 'col' in p) s += `<br>row: ${p.row} · col: ${p.col}`;
    return s;
  }

  // Layer + threshold
  let layer;
  function draw(threshold) {
    if (layer) map.removeLayer(layer);
    layer = L.geoJSON({
      type: 'FeatureCollection',
      features: features.filter(f => Number(f.properties[probCol]) >= threshold)
    }, {
      pointToLayer: (f, latlng) => {
        const p = Number(f.properties[probCol]);
        return L.circleMarker(latlng, {
          renderer: map.getRenderer(map), radius: 3.2,
          fillColor: getColor(p), color: '#000', weight: 0.2,
          opacity: 0.9, fillOpacity: 0.85
        }).bindPopup(propsPopup(f.properties, probCol));
      }
    }).addTo(map);

    try {
      const b = layer.getBounds();
      if (b.isValid()) map.fitBounds(b.pad(0.05), { animate: false });
    } catch(_) {}
  }

  draw(Number(th.value));

  // Slider
  let tId = null;
  th.addEventListener('input', () => {
    thv.textContent = Number(th.value).toFixed(2);
    clearTimeout(tId);
    tId = setTimeout(() => draw(Number(th.value)), 80);
  });
})();
</script>
</body>
</html>
